/*
    Nextflow config: tuned for Genomics cluster
    Partitions:
        vm-cpu   → 64 GB nodes (general workloads)
        big-ram  → 162 GB node (medium memory jobs)
        huge-ram → 257 GB node (heavy memory, BAKTA full DB)
*/

profiles {
    slurm {
        process {

            executor = 'slurm'
            queue = 'vm-cpu,big-ram,huge-ram'

            /*
             * IMPORTANT:
             * Do NOT set memory in clusterOptions.
             * Nextflow will emit --mem automatically.
             */
            clusterOptions = {
                "-o slurm_logs_${task.process}.%j.out " +
                "-e slurm_logs_${task.process}.%j.err"
            }

            /*
             * DEFAULT RESOURCES (unlabelled tasks)
             */
            cpus   = { check_max(1 * task.attempt, 'cpus') }
            memory = { check_max(6.GB * task.attempt, 'memory') }
            time   = { check_max(4.h * task.attempt, 'time') }

            /*
             * ERROR HANDLING
             */
            errorStrategy = { task.exitStatus in ([1, 137, 143, 104] + (130..145)) ? 'retry' : 'finish' }
            maxRetries = 3
            maxErrors  = -1

            //
            // LABELS
            //

            // ------------------------------
            // Small jobs → vm-cpu
            // ------------------------------
            withLabel: process_single {
                queue  = 'vm-cpu,big-ram,huge-ram'
                cpus   = 1
                memory = { check_max(6.GB * task.attempt, 'memory') }
                time   = { check_max(1.h * task.attempt, 'time') }
            }

            withLabel: process_low {
                queue  = 'vm-cpu,big-ram,huge-ram'
                cpus   = 2
                memory = { check_max(12.GB * task.attempt, 'memory') }
                time   = { check_max(4.h * task.attempt, 'time') }
                maxRetries = 2
            }

            // ------------------------------
            // Medium jobs → big-ram
            // ------------------------------
            withLabel: process_medium {
                queue  = 'vm-cpu,big-ram,huge-ram'
                cpus   = 6
                memory = { check_max(48.GB * task.attempt, 'memory') }
                time   = { check_max(8.h * task.attempt, 'time') }
            }

            // ------------------------------
            // High jobs → big-ram / huge-ram
            // ------------------------------
            withLabel: process_high {
                queue  = 'big-ram,huge-ram'
                cpus   = 8
                memory = { check_max(75.GB * task.attempt, 'memory') }
                time   = { check_max(16.h * task.attempt, 'time') }
                maxRetries = 3
            }

            // ------------------------------
            // High memory jobs → huge-ram
            // ------------------------------
            withLabel: process_high_memory {
                queue  = 'huge-ram'
                cpus   = 12
                memory = { check_max(120.GB * task.attempt, 'memory') }
                time   = { check_max(24.h * task.attempt, 'time') }
                maxRetries = 2
            }

            // ------------------------------
            // Special error handling
            // ------------------------------
            withLabel: error_ignore {
                errorStrategy = 'ignore'
            }

            withLabel: error_retry {
                errorStrategy = 'retry'
                maxRetries = 3
            }

            // ------------------------------
            // REQUIRED nf-core PROCESS
            // ------------------------------
            withName: CUSTOM_DUMPSOFTWAREVERSIONS {
                cpus   = 1
                memory = 1.GB
                time   = 10.m
                cache  = false
            }
        }
    }
}

/*
 * SAFETY FUNCTION: prevent resource overflow
 * MUST be in the same config file
 */
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (params.max_memory && obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "### ERROR ### Invalid max_memory '${params.max_memory}', using default: $obj"
            return obj
        }
    }
    else if (type == 'time') {
        try {
            if (params.max_time && obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "### ERROR ### Invalid max_time '${params.max_time}', using default: $obj"
            return obj
        }
    }
    else if (type == 'cpus') {
        try {
            return params.max_cpus ? Math.min(obj, params.max_cpus as int) : obj
        } catch (all) {
            println "### ERROR ### Invalid max_cpus '${params.max_cpus}', using default: $obj"
            return obj
        }
    }
}
